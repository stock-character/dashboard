<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>311 Service Request Dashboard</title>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- SheetJS (xlsx) for reading Excel files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <!-- Leaflet.js for maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Leaflet.heat for heatmap layer -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <style>
        /* Custom styles to complement Tailwind */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #f9fafb; /* text-gray-50 */
        }
        .chart-card {
            background-color: #1f2937; /* bg-gray-800 */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem; /* p-6 */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        header h1 {
            color: #ffffff; /* text-white */
        }
        header p {
            color: #d1d5db; /* text-gray-300 */
        }
        /* Style for the custom file upload button */
        .file-input-label {
            cursor: pointer;
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background-color: #3b82f6; /* bg-blue-600 */
            color: white;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
        }
        .file-input-label:hover {
            background-color: #2563eb; /* bg-blue-700 */
        }
        /* Hide the default file input */
        #file-input {
            display: none;
        }
        /* Style for filter dropdowns */
        .filter-select {
            background-color: #374151; /* bg-gray-700 */
            border-color: #4b5563; /* border-gray-600 */
            color: #f9fafb; /* text-gray-50 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem;
            width: 100%;
        }
        #upload-section {
             background-color: #1f2937;
        }
        #upload-section h2 {
            color: #ffffff;
        }
         #upload-section p {
            color: #d1d5db;
        }
        .chart-card h3 {
             color: #f9fafb;
        }
        #total-requests {
            color: #ffffff;
        }
        #data-as-of-date {
            color: #9ca3af;
        }
        .filter-select label {
            color: #d1d5db;
        }
        /* Custom Legend CSS */
        .legend {
            background-color: rgba(31, 41, 55, 0.8); /* bg-gray-800 with opacity */
            padding: 10px;
            border-radius: 5px;
            color: #f9fafb;
            width: 80px;
        }
        .legend .gradient {
            width: 100%;
            height: 100px;
            border-radius: 3px;
            /* Gradient matches the heatmap's gradient */
            background: linear-gradient(to top, blue 20%, lime 40%, red 80%);
        }
        .legend .labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold">311 Service Request (SR) Dashboard</h1>
            <p class="mt-2 text-lg">Upload your data to instantly visualize service requests.</p>
        </header>

        <!-- File Upload Section -->
        <div id="upload-section" class="max-w-xl mx-auto text-center p-6 rounded-xl shadow-lg">
            <h2 class="text-xl font-semibold mb-3">Get Started</h2>
            <p class="mb-4">Select an Excel (.xlsx, .xls) or CSV (.csv) file to begin. The file should contain columns like 'SR Type', 'SR Category', 'Created Date', 'Status', 'Workflow Status', and 'Service Location'.</p>
            <label for="file-input" class="file-input-label">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                </svg>
                Upload 311 Data
            </label>
            <input type="file" id="file-input" accept=".xlsx, .xls, .csv">
            <p id="loading-message" class="mt-4 text-blue-400 hidden">Processing your file...</p>
            <p id="error-message" class="mt-4 text-red-400 hidden"></p>
        </div>

        <!-- Dashboard Content - Initially Hidden -->
        <main id="dashboard-content" class="hidden">
            <!-- Key Performance Indicators (KPIs) -->
            <section class="mb-8 flex justify-center">
                <div class="chart-card text-center w-full max-w-sm">
                    <h3 class="text-lg font-medium">Total Requests</h3>
                    <p id="total-requests" class="text-4xl font-bold mt-2">0</p>
                    <p id="data-as-of-date" class="text-sm mt-2">-</p>
                </div>
            </section>

            <!-- Heatmap Section -->
            <section class="chart-card mb-6">
                <h3 class="text-xl font-semibold mb-4 text-center">Service Request Heatmap</h3>
                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <div class="flex-1">
                        <label for="sr-type-filter" class="block text-sm font-medium mb-1">Filter by SR Type</label>
                        <select id="sr-type-filter" class="filter-select"></select>
                    </div>
                    <div class="flex-1">
                        <label for="sr-category-filter" class="block text-sm font-medium mb-1">Filter by SR Category</label>
                        <select id="sr-category-filter" class="filter-select"></select>
                    </div>
                </div>
                <div id="heatmap" style="height: 500px; border-radius: 0.5rem; background-color: #4b5563;"></div>
                 <p class="text-xs text-gray-500 mt-2">Note: Heatmap requires a 'Service Location' column with coordinates, e.g., "(40.71, -74.00)".</p>
            </section>

            <!-- Charts Section -->
            <section class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="chart-card">
                    <h3 class="text-xl font-semibold mb-4 text-center">Requests by SR Type</h3>
                    <canvas id="requestsByTypeChart"></canvas>
                </div>
                <div class="chart-card">
                    <h3 class="text-xl font-semibold mb-4 text-center">Requests by SR Category</h3>
                    <canvas id="requestsByCategoryChart"></canvas>
                </div>

                <!-- Increased height for this chart by placing it in a full-width container -->
                <div class="chart-card lg:col-span-2" style="height: 600px;">
                     <h3 class="text-xl font-semibold mb-4 text-center">Requests by Workflow Status</h3>
                    <canvas id="requestsByWorkflowChart"></canvas>
                </div>

                <!-- New chart for requests by hour -->
                <div class="chart-card" style="height: 400px;">
                     <h3 class="text-xl font-semibold mb-4 text-center">Requests by Hour of Day</h3>
                    <canvas id="requestsByHourChart"></canvas>
                </div>

                <!-- New chart for requests by day of week -->
                <div class="chart-card" style="height: 400px;">
                     <h3 class="text-xl font-semibold mb-4 text-center">Requests by Day of Week</h3>
                    <canvas id="requestsByDayChart"></canvas>
                </div>

                 <div class="chart-card">
                    <h3 class="text-xl font-semibold mb-4 text-center">Request Status</h3>
                    <div class="max-w-xs mx-auto">
                        <canvas id="statusPieChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <h3 class="text-xl font-semibold mb-4 text-center">Requests Over Time</h3>
                    <canvas id="requestsOverTimeChart"></canvas>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Store global variables for charts, map, and data
        const chartInstances = {};
        let map;
        let heatLayer;
        let legendControl; // Variable to hold the legend
        let allData = [];
        let columnMap = {};

        // Listen for file input changes
        document.getElementById('file-input').addEventListener('change', handleFile);

        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const loadingMessage = document.getElementById('loading-message');
            const errorMessage = document.getElementById('error-message');
            const dashboardContent = document.getElementById('dashboard-content');
            
            loadingMessage.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            dashboardContent.classList.add('hidden');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = e.target.result;
                    const workbook = XLSX.read(data, { type: 'binary', cellDates: true });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);
                    
                    if(jsonData.length === 0) throw new Error("The selected file is empty or in an unsupported format.");

                    processData(jsonData);
                    
                    dashboardContent.classList.remove('hidden');
                    document.getElementById('upload-section').classList.add('hidden');
                    
                    // Defer map initialization until after the dashboard is visible.
                    setTimeout(() => {
                        initializeFilters();
                        initializeHeatmap(); // This creates the map and draws the layer
                    }, 0); // A 0ms timeout waits for the browser's next render cycle.

                } catch (error) {
                    console.error("Error processing file:", error);
                    errorMessage.textContent = `Error: ${error.message}. Please check the file and column names.`;
                    errorMessage.classList.remove('hidden');
                } finally {
                    loadingMessage.classList.add('hidden');
                }
            };
            reader.onerror = () => {
                errorMessage.textContent = "Error reading the file.";
                errorMessage.classList.remove('hidden');
                loadingMessage.classList.add('hidden');
            };
            reader.readAsBinaryString(file);
        }

        function processData(data) {
            // Store all data globally
            allData = data;

            // Define expected columns
            let expectedColumns = {
                requestType: 'SR Type',
                category: 'SR Category',
                createdDate: 'Created Date',
                status: 'Status',
                workflowStatus: 'Workflow Status',
                location: 'Service Location'
            };

            // Find actual column names (case-insensitive) and handle missing optional columns
            const firstRow = data[0];
            const foundColumns = {};
            const missingColumns = [];

            for (const key in expectedColumns) {
                const expectedHeader = expectedColumns[key];
                const foundHeader = Object.keys(firstRow).find(header => header.toLowerCase() === expectedHeader.toLowerCase());
                
                if (foundHeader) {
                    foundColumns[key] = foundHeader;
                } else {
                    missingColumns.push(expectedHeader);
                    // Use the expected name as a placeholder so the code doesn't break
                    foundColumns[key] = expectedHeader; 
                }
            }

            // Check for critical columns that MUST exist
            if (missingColumns.includes('Created Date')) {
                 throw new Error(`Critical column "Created Date" not found in the file. Most charts depend on this column.`);
            }

            // If non-critical columns are missing, log a warning to the console but continue
            if (missingColumns.length > 0) {
                const optionalMissing = missingColumns.filter(c => c !== 'Created Date');
                if (optionalMissing.length > 0) {
                    console.warn(`The following optional columns were not found and their corresponding charts may be empty: ${optionalMissing.join(', ')}`);
                }
            }
            
            // Re-assign the global columnMap to the newly found (or placeholder) columns
            columnMap = foundColumns;


            // 1. Calculate KPIs and find latest date
            const totalRequests = data.length;
            let latestDate = null;

            data.forEach(row => {
                const date = new Date(row[columnMap.createdDate]);
                if (!isNaN(date.getTime())) {
                    if (!latestDate || date > latestDate) {
                        latestDate = date;
                    }
                }
            });
            
            const openStatuses = ['open', 'in progress', 'assigned'];
            const openRequests = data.filter(d => {
                const status = d[columnMap.status];
                return status && openStatuses.includes(status.toLowerCase());
            }).length;
            const closedRequests = totalRequests - openRequests;
            
            document.getElementById('total-requests').textContent = totalRequests.toLocaleString();
            if (latestDate) {
                document.getElementById('data-as-of-date').textContent = `Data as of ${latestDate.toLocaleDateString()}`;
            }

            // 2. Prepare data for charts
            const requestsByType = countOccurrences(data, columnMap.requestType);
            const requestsByCategory = countOccurrences(data, columnMap.category);
            const requestsByWorkflow = countOccurrences(data, columnMap.workflowStatus);
            const statusCounts = { 'Open': openRequests, 'Closed': closedRequests };
            const requestsOverTime = aggregateByMonth(data, columnMap.createdDate);
            const requestsByHour = aggregateByHour(data, columnMap.createdDate);
            const requestsByDay = aggregateByDayOfWeek(data, columnMap.createdDate);

            // 3. Render charts (excluding map)
            renderBarChart('requestsByTypeChart', 'Top 10 SR Types', requestsByType, 10);
            renderBarChart('requestsByCategoryChart', 'Requests by SR Category', requestsByCategory, 10);
            renderBarChart('requestsByWorkflowChart', 'Requests by Workflow Status', requestsByWorkflow);
            renderPieChart('statusPieChart', 'Request Status', statusCounts);
            renderLineChart('requestsOverTimeChart', 'Monthly Request Volume', requestsOverTime);
            renderTemporalChart('requestsByHourChart', 'Requests by Hour of Day', requestsByHour.data, requestsByHour.labels);
            renderTemporalChart('requestsByDayChart', 'Requests by Day of Week', requestsByDay.data, requestsByDay.labels);
            
            // Map and filters will be initialized after the dashboard is visible.
        }

        function countOccurrences(data, key) {
            // Check if the key (column) exists in the data before trying to reduce it
            if (!data[0] || data[0][key] === undefined) {
                console.warn(`Column "${key}" used for a chart was not found in the data. The chart will be empty.`);
                return {};
            }
            return data.reduce((acc, row) => {
                const item = row[key] || 'Unspecified';
                acc[item] = (acc[item] || 0) + 1;
                return acc;
            }, {});
        }
        
        function aggregateByMonth(data, dateKey) {
            const counts = data.reduce((acc, row) => {
                const date = new Date(row[dateKey]);
                if (!isNaN(date.getTime())) {
                    const key = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
                    acc[key] = (acc[key] || 0) + 1;
                }
                return acc;
            }, {});
            return Object.keys(counts).sort().reduce((obj, key) => ({ ...obj, [key]: counts[key] }), {});
        }

        function aggregateByHour(data, dateKey) {
            const dataArray = Array(24).fill(0);
            data.forEach(row => {
                const date = new Date(row[dateKey]);
                if (!isNaN(date.getTime())) {
                    const hour = date.getHours(); // Returns 0-23
                    dataArray[hour]++;
                }
            });
             const labels = Array.from({ length: 24 }, (_, i) => {
                const hour = i === 0 ? 12 : i > 12 ? i - 12 : i;
                const ampm = i < 12 ? 'AM' : 'PM';
                return `${hour} ${ampm}`;
            });
            return { data: dataArray, labels: labels };
        }

        function aggregateByDayOfWeek(data, dateKey) {
            const dataArray = Array(7).fill(0); // 0 = Sunday, 6 = Saturday
            const labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            data.forEach(row => {
                const date = new Date(row[dateKey]);
                if (!isNaN(date.getTime())) {
                    const day = date.getDay();
                    dataArray[day]++;
                }
            });
            return { data: dataArray, labels: labels };
        }

        function initializeFilters() {
            const typeFilter = document.getElementById('sr-type-filter');
            const categoryFilter = document.getElementById('sr-category-filter');

            const typeCounts = countOccurrences(allData, columnMap.requestType);
            const categoryCounts = countOccurrences(allData, columnMap.category);

            const sortedTypes = Object.keys(typeCounts).sort();
            const sortedCategories = Object.keys(categoryCounts).sort();

            // Clear existing options and add the "All" option with a total count
            typeFilter.innerHTML = `<option value="All">All SR Types (${allData.length})</option>`;
            categoryFilter.innerHTML = `<option value="All">All SR Categories (${allData.length})</option>`;

            // Populate SR Type filter with counts
            sortedTypes.forEach(type => {
                if (type && type !== 'Unspecified') {
                    typeFilter.innerHTML += `<option value="${type}">${type} (${typeCounts[type]})</option>`;
                }
            });
            
            // Populate SR Category filter with counts
            sortedCategories.forEach(category => {
                if (category && category !== 'Unspecified') {
                    categoryFilter.innerHTML += `<option value="${category}">${category} (${categoryCounts[category]})</option>`;
                }
            });

            typeFilter.addEventListener('change', updateHeatmap);
            categoryFilter.addEventListener('change', updateHeatmap);
        }

        function initializeHeatmap() {
            if (map) {
                if (legendControl) {
                    map.removeControl(legendControl);
                }
                map.remove();
            }
            // Default center, will be adjusted by data
            map = L.map('heatmap').setView([40.7128, -74.0060], 10);
            
            // Using the standard OpenStreetMap color tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 19
            }).addTo(map);

            // Add the custom legend control
            legendControl = L.control({ position: 'bottomright' });
            legendControl.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML += '<b>Density</b>';
                div.innerHTML += '<div class="gradient"></div>';
                div.innerHTML += '<div class="labels"><span>Low</span><span>High</span></div>';
                return div;
            };
            legendControl.addTo(map);
            
            // Now that the map is visible and initialized, draw the heatmap
            updateHeatmap();
        }

        function updateHeatmap() {
            if (!map) return; // Don't try to update if map isn't initialized
            
            const selectedType = document.getElementById('sr-type-filter').value;
            const selectedCategory = document.getElementById('sr-category-filter').value;

            const filteredData = allData.filter(d => 
                (selectedType === 'All' || d[columnMap.requestType] === selectedType) &&
                (selectedCategory === 'All' || d[columnMap.category] === selectedCategory)
            );

            const heatPoints = filteredData.map(d => {
                const loc = d[columnMap.location];
                if (!loc || typeof loc !== 'string') return null;
                
                const match = loc.match(/\(?\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)?/);
                if (match && match.length === 3) {
                    return [parseFloat(match[1]), parseFloat(match[2]), 0.5]; // lat, lon, intensity
                }
                return null;
            }).filter(p => p !== null);

            if (heatLayer) {
                map.removeLayer(heatLayer);
            }

            if (heatPoints.length > 0) {
                heatLayer = L.heatLayer(heatPoints, { 
                    radius: 25,
                    blur: 20,
                    maxZoom: 18,
                    gradient: {0.2: 'blue', 0.4: 'lime', 0.8: 'red'} 
                }).addTo(map);
                map.fitBounds(heatPoints.map(p => [p[0], p[1]]));
            }
        }

        function renderBarChart(canvasId, title, dataObject, limit) {
            // Handle case where data object might be empty because column was missing
            if (Object.keys(dataObject).length === 0) {
                const ctx = document.getElementById(canvasId).getContext('2d');
                if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
                // Optionally display a message on the canvas
                return;
            }

            let sortedData = Object.entries(dataObject).sort(([, a], [, b]) => b - a);
            if (limit) sortedData = sortedData.slice(0, limit);
            
            const labels = sortedData.map(entry => entry[0]);
            const data = sortedData.map(entry => entry[1]);

            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
            
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Number of Requests',
                        data,
                        backgroundColor: 'rgba(59, 130, 246, 0.5)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: true, indexAxis: 'y',
                    scales: {
                        x: { ticks: { color: '#d1d5db' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { ticks: { color: '#d1d5db' }, grid: { display: false } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        function renderTemporalChart(canvasId, title, dataArray, labels) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Requests',
                        data: dataArray,
                        backgroundColor: 'rgba(59, 130, 246, 0.5)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'x', // Vertical bars
                    scales: {
                        x: { ticks: { color: '#d1d5db' }, grid: { display: false } },
                        y: { ticks: { color: '#d1d5db' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        function renderPieChart(canvasId, title, dataObject) {
            const labels = Object.keys(dataObject);
            const data = Object.values(dataObject);
            
            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
            
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels,
                    datasets: [{
                        data,
                        backgroundColor: ['rgba(252, 211, 77, 0.7)', 'rgba(52, 211, 153, 0.7)'],
                        borderColor: ['rgba(252, 211, 77, 1)', 'rgba(52, 211, 153, 1)'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: true,
                    plugins: { legend: { position: 'top', labels: { color: '#d1d5db' } } }
                }
            });
        }

        function renderLineChart(canvasId, title, dataObject) {
            const labels = Object.keys(dataObject);
            const data = Object.values(dataObject);

            const ctx = document.getElementById(canvasId).getContext('2d');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
            
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Number of Requests',
                        data,
                        fill: true,
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: true,
                    scales: {
                        x: { ticks: { color: '#d1d5db' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                        y: { ticks: { color: '#d1d5db' }, beginAtZero: true, grid: { color: 'rgba(255,255,255,0.1)' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }
    </script>
</body>
</html>

